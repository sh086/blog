# 迁移代码至CNB部署

>  [官方文档](https://docs.cnb.cool/zh/build/quick-start.html) |[参考资料](https://falling42.net/article/ot9yjvvt/#%E6%9E%84%E5%BB%BA%E5%B9%B6%E6%8E%A8%E9%80%81-docker-%E9%95%9C%E5%83%8F) | [示例](https://cnb.cool/examples/ecosystem/springboot-gradle-docker)



## 一、代码迁移

### 1、创建仓库

​	　登录`cnb`后，点击`创建仓库`，进入创建页面，按要求填写即可。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128162753884.9ddgyj4pe2.webp"/>



### 2、仓库初始化

​	　这里我们采用云端快速初始化的方式初始化仓库。先点击`README`的超链接，不需要更改内容，立即点提交，然后在弹出的窗口选择[直接提交到`main`分支]，这样在提交后，系统就会自动为我们创建`main`主分支。

​	　注意，这里主分支名称建议与老项目的主分支名称相同，若老项目主分支名称不为`main`，则此处需先选择[为这次提交创建一个新分支]，然后新建一个与老项目主分支名称一致的分支作为新仓库的主分支。

<Img src='https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128164254825.86u5pxgids.webp'/>



### 3、代码迁移

​	　在老项目目录下运行如下Git命令，推送老项目的全部分支上的代码、提交记录等到cnb仓库。

```shell
# ① 使用sourcetree[获取]最新代码和分支
# ② 将老项目指向cnb的新地址
git remote set-url origin <CNB新仓库地址>
# ③ 推送全部分支上的代码、提交记录到cnb仓库
git push --mirror <CNB新仓库地址>
```

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260129140623333.9gx2w9bgwf.webp"/>



## 二、项目构建文件

### 1、DockerFile

> 文件位置：.Dockerfile

```dockerfile
# 拉取JDK
FROM openjdk:8-jdk-slim

# 设置时区
ENV TZ=Asia/Shanghai

# 启动程序
WORKDIR /opt/目录名
COPY target/生成的jar包.jar .
EXPOSE 8080
CMD java -jar -Dspring.profiles.active=test -Dserver.port=8014 ./项目jar包.jar
```



### 2、Maven镜像地址

​	　为保证项目构建速度，建议使用下面的Maven镜像地址。

> 文件位置：.settings.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 
          http://maven.apache.org/xsd/settings-1.0.0.xsd">
    
    <mirrors>
        <!-- 阿里云镜像 -->
        <mirror>
            <id>aliyun-maven</id>
            <mirrorOf>central</mirrorOf>
            <name>Aliyun Maven Repository</name>
            <url>https://maven.aliyun.com/repository/central</url>
        </mirror>
        
        <!-- 华为云镜像 -->
        <mirror>
            <id>huaweicloud</id>
            <mirrorOf>central</mirrorOf>
            <url>https://repo.huaweicloud.com/repository/maven/</url>
        </mirror>
        
        <!-- 腾讯云镜像 -->
        <mirror>
            <id>tencent-cloud</id>
            <mirrorOf>central</mirrorOf>
            <url>https://mirrors.cloud.tencent.com/nexus/repository/maven-public/</url>
        </mirror>
    </mirrors>
    
    <profiles>
        <profile>
            <id>default</id>
            <activation>
                <activeByDefault>true</activeByDefault>
            </activation>
            <repositories>
                <repository>
                    <id>central</id>
                    <url>https://repo.maven.apache.org/maven2</url>
                    <releases><enabled>true</enabled></releases>
                    <snapshots><enabled>true</enabled></snapshots>
                </repository>
            </repositories>
        </profile>
    </profiles>
</settings>
```



## 三、CNB云原生构建

​	　当 `云原生构建` 接收到各类事件时，会自动从仓库对应分支获取 `.cnb.yml` 配置文件，解析出该分支下对应事件的流水线配置，并分配 Runner 执行构建任务。下面就开始配置CNB云原生流水线配置。

### 1、页面操作事件

​	　首先，配置自定义部署按钮，该按钮可在CNB仓库的【代码Tab页】的【执行】下拉框展示。这里我们配置的是`main分支`展示`部署生产`按钮，`develop`分支展示`部署测试`按钮。

> 文件位置：.cnb/web_trigger.yml

```yml
branch:
  # 如下按钮在分支名以 main 开头的分支详情页面显示
  - reg: ^main
    buttons:
      - name: 部署生产
        # 按钮标题
        description: 部署生产
        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment

  # 如下按钮在分支名以 dev 开头的分支详情页面显示
  - reg: ^dev
    buttons:
      - name: 部署测试
        # 按钮标题
        description: 部署测试
         # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment

```



​	　然后，在`.cnb.yml`中配置自定义按钮可触发的事件。

> 文件位置：.cnb.yml

```yml
# 定义执行构建&推送方法
docker-job: &docker-job
    docker:
      image: maven:3.8.6-openjdk-8
      volumes:
        # 声明式的构建缓存
        - /root/.m2:copy-on-write
    services:
      # 流水线中启用 docker 服务
      - docker
    stages:
      # 打印最后一次提交日志
      - name: print-last-commit
        script:
          - echo "最后一次提交："
          - git log -1

      # 打包
      - name: mvn package
        script: mvn clean package -DskipTests

      # 构建 & 推送镜像
      - name: docker-build-push
        script:
         - IMAGE_TAG=$(if [ "$CNB_BRANCH" = "main" ]; then echo "prod"; else echo "fat"; fi)
         # 构建镜像
         - docker build -t ${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG .
         # 推送镜像到cnb仓库
         - docker push ${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG
         - echo "推送镜像：${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG"

# 用于页面按钮发布
"**":
  #自定义按钮可触发的事件
  web_trigger_deployment:
    #执行构建&推送
    - <<: *docker-job
```



​	　代码提交后，选择不同的分支，即可看到对应的部署按钮。如，点击`部署测试`，即可生成测试环境的镜像。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128175506440.1zirprokgx.webp"/>

​	　若构建中提示错误，使用自带的AI分析可解决问题。部署完成后，在`制品`Tab栏可以看到生成的镜像。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260129170835477.8vnf9y8udr.webp"/>

### 2、Git操作事件

​	　生产环境发布时，为了安全，可以通过人工确认后点击按钮部署。但是，为了便于测试环境部署，我们这里还配置了测试环境`push`后自动生成镜像的流程。

> 文件位置：.cnb.yml

```yml{5-9}
...[这里是上面的.cnb.yml配置] ...

# 以下在原有的配置中追加
# 用于Git推送时部署
dev*:
  # 事件名
  push:
    #执行构建&推送
    - <<: *docker-job
```

​	　将本次修改**提交 (Commit) 并推送 (Push)** 到远程 `main` 分支后，流水线将自动触发。点击 `云原生构建` 标签页，查看所有构建记录。 

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260129134909491.7psuv9vtu.webp"/>



### 3、API和TASK分离部署

​	　对于一些复杂的部署，如需要生产环境的`API`和`TASK`分离部署的，我们可以在构建镜像时，通过使用不同的`Dockerfile`和设置不同的`IMAGE_TAG`版本来实现。

**（1）Dockerfile负责部署定时任务，Dockerfile负责部署API**

 ① 对由`@Scheduled`控制的定时任务，具体请参照[这里](https://sh086.github.io/blog/docs/develop/2025/20251023_SpringBoot%E5%8A%A8%E6%80%81%E5%8C%96%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1)

```shell
# 启动定时任务的配置：Dockerfile
CMD java -jar -Denable.scheduled=true  ./项目.jar
# 关闭定时任务的配置，只允许API访问：DockerfileAPi
CMD java -jar -Denable.scheduled=false  ./项目.jar
```

 ② 对于由xxl-job控制的定时任务

​	　通过给`appname`注入一个不存在的执行器名称，即可实现定时任务不被`xxl-job`调用的效果。

```shell
# 启动定时任务的配置：Dockerfile
CMD java -jar -Dxxl.job.executor.appname=执行器名称 ./项目.jar
# 关闭定时任务的配置，只允许API访问：DockerfileAPi
CMD java -jar -Dxxl.job.executor.appname=一个不存在的执行器名称 ./项目.jar
```

​	　

**（2）页面按钮传入镜像版本,生产TASK是`prod_task`，生产API是`prod_api`**

```yml{11,12,20,21,30,31}
branch:
  # 如下按钮在分支名以 main 开头的分支详情页面显示
  - reg: ^main
    buttons:
      - name: 部署生产TASK
        # 按钮标题
        description: 部署生产TASK
        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment
        # 显示声明镜像版本
        env:
          IMAGE_TAG: prod_task

      - name: 部署生产API
        # 按钮标题
        description: 部署生产API
        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment
        # 显示声明镜像版本
        env:
          IMAGE_TAG: prod_api

  # 如下按钮在分支名以 dev 开头的分支详情页面显示
  - reg: ^dev
    buttons:
      - name: 部署测试
        # 按钮标题
        description: 部署测试
        # 显示声明镜像版本
        env:
          IMAGE_TAG: fat
```



**（3）当镜像版本是`prod_api`则根据`DockerfileApi`构建镜像，其它根据`Dockerfile`构建**

```yml{26,28,48,49}
# 定义执行构建&推送方法
docker-job: &docker-job
    docker:
      image: maven:3.8.6-openjdk-8
      volumes:
        # 声明式的构建缓存
        - /root/.m2:copy-on-write
    services:
      # 流水线中启用 docker 服务
      - docker
    stages:
      # 打印最后一次提交日志
      - name: print-last-commit
        script:
          - echo "最后一次提交："
          - git log -1

      # 打包
      - name: mvn package
        script: mvn clean package -DskipTests

      # 构建 & 推送镜像
      - name: docker-build-push
        script:
         # 设置构建时使用的Dockerfile
         - DOCKER_FILE=$(if [ "$IMAGE_TAG" = "prod_api" ]; then echo "DockerfileApi"; else echo "Dockerfile"; fi)
         # 构建镜像
         - docker build -f ${DOCKER_FILE} -t ${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG .
          # 推送镜像到cnb仓库
         - docker push ${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG
         - echo "使用的构建文件：${DOCKER_FILE}"
         - echo "推送镜像：${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}:$IMAGE_TAG"

# 用于页面按钮发布
"**":
  #自定义按钮可触发的事件
  web_trigger_deployment:
    #执行构建&推送
    - <<: *docker-job

# 用于Git推送时部署
dev*:
  # 事件名
  push:
    #执行构建&推送
    - <<: *docker-job
      # 设置生成的镜像标签
      env:
        IMAGE_TAG: fat
```



### 4、带时间戳的备份TAG

​	　在生产分支构建时，需要增加一个`带时间戳的TAG镜像`进行备份推送，以便在需求上线后发现异常后，能够及时回滚到上一次发布。配置改动如下：



> 文件位置：.cnb.yml

```YML{24-63}
# 定义执行构建&推送方法
docker-job: &docker-job
    docker:
      image: maven:3.8.6-openjdk-8
      volumes:
        # 声明式的构建缓存
        - /root/.m2:copy-on-write
    services:
      # 流水线中启用 docker 服务
      - docker
    stages:
      # 打印最后一次提交日志
      - name: print-last-commit
        script:
          - echo "最后一次提交："
          - git log -1

      # 打包
      - name: mvn package
        script: mvn clean package -DskipTests

      # 构建 & 推送镜像
      - name: docker-build-push
        script: |
          set -e

          # 设置仓库路径：CNB仓库地址 / 项目地址
          IMAGE_PATH=${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}

          # 根据分支决定 TAG 规则
          case "${CNB_BRANCH}" in
            master|release|main)
              # 生产环境 推送 {IMAGE_TAG} 和 ${IMAGE_TAG_EXTRA} 两个镜像
              # {IMAGE_TAG} 用于日常发布
              # ${IMAGE_TAG_EXTRA} 用于回滚
              IMAGE_TAG_EXTRA="${IMAGE_TAG}-$(date +%Y%m%d%H%M%S)"
              IMAGE_LIST="${IMAGE_PATH}:${IMAGE_TAG} ${IMAGE_PATH}:${IMAGE_TAG_EXTRA}"
              ;;
            develop|dev)
              # 测试环境 推送 {IMAGE_PATH}:${IMAGE_TAG} 镜像
              IMAGE_LIST="${IMAGE_PATH}:${IMAGE_TAG}"
              ;;
            *)
              # 其它情况
              echo "当前分支不构建镜像"
              exit 0
              ;;
          esac

          # 根据 IMAGE_TAG 选择 Dockerfile
          if [ "${IMAGE_TAG}" = "prod_api" ]; then
            DOCKER_FILE="DockerfileApi"
          else
            DOCKER_FILE="Dockerfile"
          fi
          echo "使用的构建文件：${DOCKER_FILE}"

          # 推送所有TAG到镜像仓库
          for IMAGE in ${IMAGE_LIST}; do
            docker build -f ${DOCKER_FILE} -t ${IMAGE} .
            docker push ${IMAGE}
            echo "推送镜像：${IMAGE}"
          done

# 用于页面按钮发布
"**":
  #自定义按钮可触发的事件
  web_trigger_deployment:
    #执行构建&推送
    - <<: *docker-job

# 用于Git推送时部署
dev*:
  # 事件名
  push:
    #执行构建&推送
    - <<: *docker-job
      # 设置生成的镜像标签
      env:
        IMAGE_TAG: fat
```



## 四、部署运行

### 1、生成访问令牌

​	　点击`个人设置` ，在侧边栏选择`访问令牌` ，然后点击`添加访问令牌`按钮，即可弹出如下页面进行添加，完成后**记得保存弹出的`UserName`和`Token`**。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128180253143.70auhc0swn.webp"/>



### 2、更新部署策略

​	　进入腾讯云K8s，然后，点击`更新pod配置`，开始更新Pod的镜像配置。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128180827640.2a5lix9uz4.webp"/>

​	　第一点就是，首次是需要新增K8S访问CNB制品库的访问令牌，迁移第二个项目时就可使用改令牌无需再次新增了。注意，生产和测试第一次都是需要新增的。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260128181456369.32ih0nqz44.webp"/>

​	　第二点就是，需要选择`镜像地址`为CNB的新镜像地址和镜像版本，镜像地址和镜像版本可以在`CNB`的`制品`中查看。

<Img src="https://github.com/sh086/picx-images-hosting/raw/master/20260129/image-20260129143217140.6t7mlwgrke.webp"/>

​	　配置完成后，点击`更新配置`按钮，等K8S重新部署后即可完成容器部署。



## 附录

> 文件位置：.cnb/web_trigger.yml

```yml
branch:
  # 如下按钮在分支名以 master|main|release 开头的分支详情页面显示
  - reg: ^(master|main|release)$
    buttons:
      - name: 部署生产TASK
        # 按钮标题
        description: 部署生产TASK
        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment
        # 显示声明镜像版本
        env:
          IMAGE_TAG: prod_task

      - name: 部署生产API
        # 按钮标题
        description: 部署生产API
        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
        event: web_trigger_deployment
        # 显示声明镜像版本
        env:
          IMAGE_TAG: prod_api

#      - name: 部署生产环境
#        # 按钮标题
#        description: 部署生产环境
#        # 触发的 CI 事件名，需要在 .cnb.yml 中配置
#        event: web_trigger_deployment
#        # 显示声明镜像版本
#        env:
#          IMAGE_TAG: prod

  # 如下按钮在分支名以 dev 开头的分支详情页面显示
  - reg: ^develop
    buttons:
      - name: 部署测试
        # 按钮标题
        description: 部署测试
        # 显示声明镜像版本
        env:
          IMAGE_TAG: fat
```



> 文件位置：.cnb.yml

```yml
# 定义执行构建&推送方法
docker-job: &docker-job
    docker:
      image: maven:3.8.6-openjdk-8
      volumes:
        # 声明式的构建缓存
        - /root/.m2:copy-on-write
    services:
      # 流水线中启用 docker 服务
      - docker
    stages:
      # 打印最后一次提交日志
      - name: print-last-commit
        script:
          - echo "最后一次提交："
          - git log -1

      # 打包
      - name: mvn package
        script: mvn clean package -DskipTests

      # 构建 & 推送镜像
      - name: docker-build-push
        script: |
          set -e

          # 设置仓库路径：CNB仓库地址 / 项目地址
          IMAGE_PATH=${CNB_DOCKER_REGISTRY}/${CNB_REPO_SLUG_LOWERCASE}

          # 根据分支决定 TAG 规则
          case "${CNB_BRANCH}" in
            master|release|main)
              # 生产环境 推送 {IMAGE_TAG} 和 ${IMAGE_TAG_EXTRA} 两个镜像
              # {IMAGE_TAG} 用于日常发布
              # ${IMAGE_TAG_EXTRA} 用于回滚
              IMAGE_TAG_EXTRA="${IMAGE_TAG}-$(date +%Y%m%d%H%M%S)"
              IMAGE_LIST="${IMAGE_PATH}:${IMAGE_TAG} ${IMAGE_PATH}:${IMAGE_TAG_EXTRA}"
              ;;
            develop|dev)
              # 测试环境 推送 {IMAGE_PATH}:${IMAGE_TAG} 镜像
              IMAGE_LIST="${IMAGE_PATH}:${IMAGE_TAG}"
              ;;
            *)
              # 其它情况
              echo "当前分支不构建镜像"
              exit 0
              ;;
          esac

          # 根据 IMAGE_TAG 选择 Dockerfile
          if [ "${IMAGE_TAG}" = "prod_api" ]; then
            DOCKER_FILE="DockerfileApi"
          else
            DOCKER_FILE="Dockerfile"
          fi
          echo "使用的构建文件：${DOCKER_FILE}"

          # 推送所有TAG到镜像仓库
          for IMAGE in ${IMAGE_LIST}; do
            docker build -f ${DOCKER_FILE} -t ${IMAGE} .
            docker push ${IMAGE}
            echo "推送镜像：${IMAGE}"
          done

# 用于页面按钮发布
"**":
  #自定义按钮可触发的事件
  web_trigger_deployment:
    #执行构建&推送
    - <<: *docker-job

# 用于Git推送时部署
dev*:
  # 事件名
  push:
    #执行构建&推送
    - <<: *docker-job
      # 设置生成的镜像标签
      env:
        IMAGE_TAG: fat
```

