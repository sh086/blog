---
sidebar: auto
---
# 微服务简介




**文档：**

- [微服务从设计到部署](https://github.com/senghoo/golang-design-pattern)
- [重构-改善既有代码的设计](http://gdut_yy.gitee.io/doc-refact2/)
- 研磨设计模式
- 架构即未来



## 走进单体地狱

​	　单体应用多用于 **项目规模较小、用户较少** 或者 **企业内部** 使用的应用，不适合开发具有高可用、高并发、高性能特性的互联网应用。

### 早期单体

​	　在项目的早期阶段，使用单体应用开发`互联网应用`也可以良好运作。开发者可以快速通过IDEA开发风格类似的单体应用模型，通过简单地启动并使用如`Selenium`测试包来测试`UI`，以轻松地实现**端到端 (end-to-end) 测试**。此外，应用程序被作为一个单体易于打包和部署，只需将拷贝打包好的应用程序上传到服务器上运行即可。通过运行**多个副本**和结合**负载均衡器**，可以很方便的扩展单体应用。



### 单体地狱

​	　但是，随着时间推移，小而简单的应用将会逐渐成长成一个**庞大**、**复杂**的单体，应用程序变得难以扩展，不可靠。敏捷开发和交付的任何一次尝试都将原地徘徊，正确修复 bug 和实现新功能变得非常困难而耗时。应用启动时间的不断变长和因变更所需要进行的大量测试，导致复杂单体持续部署变得非常困难。当不同模块存在资源（CPU密集型和内存密集型）需求冲突时，单体应用可能难以扩展。任何模块的一个bug都可能会拖垮整个进程，影响到整个应用的可用性。单体应用也使得采用新框架和语言变得非常困难。



## 微服务架构

​	　微服务将单体应用根据业务需求**充分分解**成一套**较小的互连服务**，以实现**松耦合**，达到应用敏捷开发和部署的目的。每个微服务都是实现了一组不同的特性或功能的**自包含**应用，可以根据不同的业务需求选择**相适应业务**的 **数据库模式**  和 **用例部署场景**。

​	　**每个服务可由多个服务实例组成**，每个服务实例是一个Docker容器，为了实现高可用，容器是在多个云虚拟机上运行的。通过**服务发现机制**使得服务能够发现**需要与之通信的任何其他服务的位置**（主机和端口）。不同的服务用例之间进行跨实例分发请求时，不能直接通过 `REST API` 访问，而是需要通过 **API 网关** (API Gateway) 进行**异步、基于消息的通信**，**API 网关负责负载均衡、缓存、访问控制、 API 计量和监控**， 可以通过使用`NGINX` 来实现。



### 微服务优缺

​	　微服务架构模式强制一定程度的模块化，每个服务都有一个明确定义边界的方式，使得**个体服务能被更快地开发，并更容易理解与维护**。开发者可以自由选择与当前业务需求相适应的技术，此外使用当前技术重写旧服务将变得更加可行。微服务可以实现每个微服务独立部署，使得变更一经测试即可立即部署。微服务架构模式使得每个服务能够独立扩展使用与服务资源要求最匹配的硬件。

​	　但是，微服务架构模式也容易**过多偏向于小型化服务的规模**，而**忽略**充分分解业务需求以方便应用敏捷开发和部署的目标。微服务是一个分布式系统，其使得整体变得复杂，容易出现局部故障。分区数据库架构难以实现分布式事务，**不得不使用基于最终一致性的方法保证数据的一致性**。测试某个微服务的功能时，需要启动该服务及其所依赖的所有服务，实现跨服务需求变更时，需要仔细规划和协调出现的变更至每个服务。

​	　部署基于微服务的应用程序也是相当复杂的，微服务应用程序通常由大量的服务组成，每个服务都有多个运行时实例、还有更多的移动部件需要配置、部署、扩展和监控，因此，要成功部署微服务应用程序，需要求开发人员能**高度控制部署方式**和**高度自动化**。一种自动化方式是使用现成的`PaaS`，如 `Cloud Foundry`；另一个方式是使用`Kubernetes`集群方案开发自己的 `PaaS`。



### CAP理论

​	　CAP 理论指一个分布式系统最多只能同时满足**一致性**（Consistency）、**可用性**（Availability）和**分区容错性**（Partition tolerance）这**三项中的两项**。互联网应用常见的是**必须保证C**，P和A可根据业务选择。

```
① 一致性：更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致
② 可用性：服务一直可用，而且是正常响应时间
③ 分区容错性：在遇到某节点或网络分区故障时，仍能对外提供满足一致性和可用性的服务
```



## 再谈微服务

