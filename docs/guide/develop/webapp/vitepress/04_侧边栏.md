# 侧边栏

## 人工配置

### 单一文件配置

​	　首先，在`config.mts`同级目录下新建`sidebar.js`，并配置如下示例：
::: code-group

```js [.vitepress/sidebar.js]
export default {
    '/': [
      {
        text: '示例',
        collapsed: false,
        items: [
          { text: 'markdown-example', link: '/markdown-examples.md'},
          { text: 'api-examples', link: '/api-examples.md'},
        ]
      },
    ],
}
```

:::

​	　最后在`config.mts`中引入`./sidebar.js`即可。

::: code-group
```js [.vitepress/config.mts] {1,5}
import sidebar from "./sidebar"

export default defineConfig({
  themeConfig: {
    sidebar: sidebar,
  },
})
```
:::

### 多配置文件
​	　若侧边栏配置较多，可以在`.vitepress下`新建一个`sidebar`文件夹单独存放所有的侧边栏配置。
::: code-group
```js [.vitepress/sidebar/webapp.js] {6-8,15}
const vitepress =  [
  {
    text: '测试',
    collapsed: false,
    items: [
      // link需要使用全路径,不能使用相对路径 否则侧边栏选中项变成蓝色 这一效果会失效
      { text: 'markdown-example', link: '/markdown-examples.md'},
      { text: 'api-examples', link: '/api-examples.md'},
    ]
  },
]

// 多个导出使用因为逗号分隔
// export {vite1,vite2}
export {vitepress}
```
:::
​	　最后在`siderbar.js`中引入`./sidebar/webapp.js`即可

::: code-group
```js [.vitepress/siderbar.js] {1,4}
import {vitepress} from './sidebar/webapp.js'

export default {
  '/':vitepress
}
```
:::

## 自动配置

### 自定义脚本

> [!WARNING] 警告
> 不建议自动配置sidebar
​	　首先，将`auto-gen-sidebar.mjs`放到在`config.mts`同级目录下，然后在`sidebar.js`新增如下配置：

```js
import { set_sidebar } from "./auto-gen-sidebar.mjs";
export default {
    // 第一个参数：常常是nav的link
    // 第二个参数：是相对于根路径的文件夹路径，返回的是每个文件夹中文件的名称和链接
    "/docs/": set_sidebar("/docs/")
}
```

​	　特别注意，自动配置`sidebar`**脚本生成的 访问路径 和 文件层级 是一样的**，所以，是**不能配置`srcDir: './docs'`的**。


::: details auto-gen-sidebar.mjs
```js
import path from "node:path";
import fs from "node:fs";

// 文件根目录
const DIR_PATH = path.resolve();
// 白名单,过滤不是文章的文件和文件夹
const WHITE_LIST = [
  "index.md",
  ".vitepress",
  "node_modules",
  ".idea",
  "assets",
];

// 判断是否是文件夹
const isDirectory = (path) => fs.lstatSync(path).isDirectory();

// 取差值
const intersections = (arr1, arr2) =>
  Array.from(new Set(arr1.filter((item) => !new Set(arr2).has(item))));

// 把方法导出直接使用
function getList(params, path1, pathname) {
  // 存放结果
  const res = [];
  // 开始遍历params
  for (let file in params) {
    // 拼接目录
    const dir = path.join(path1, params[file]);
    // 判断是否是文件夹
    const isDir = isDirectory(dir);
    if (isDir) {
      // 如果是文件夹,读取之后作为下一次递归参数
      const files = fs.readdirSync(dir);
      res.push({
        text: params[file],
        collapsible: true,
        items: getList(files, dir, `${pathname}/${params[file]}`),
      });
    } else {
      // 获取名字
      const name = path.basename(params[file]);
      // 排除非 md 文件
      const suffix = path.extname(params[file]);
      if (suffix !== ".md") {
        continue;
      }
      res.push({
        text: name,
        link: `${pathname}/${name}`,
      });
    }
  }
  // 对name做一下处理，把后缀删除
  res.map((item) => {
    item.text = item.text.replace(/\.md$/, "");
  });
  return res;
}

export const set_sidebar = (pathname) => {
  // 获取pathname的路径
  const dirPath = path.join(DIR_PATH, pathname);
  // 读取pathname下的所有文件或者文件夹
  const files = fs.readdirSync(dirPath);
  // 过滤掉
  const items = intersections(files, WHITE_LIST);
  // getList 函数后面会讲到
  return getList(items, dirPath, pathname);
};
```
:::


### 插件
> [!WARNING] 警告
> 不建议自动配置sidebar